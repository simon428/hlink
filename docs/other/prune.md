
# 为什么有prune命令

## 说明
该命令翻译过来就是**修剪**，使用场景有以下两个
1. 正向：在源文件被删除了，但是硬链忘记删了。hlink可以帮你快速找到多余的硬链并删除
2. 反向：在硬链文件删除时，你希望能自动删除掉源文件(加计划任务)


## 举例

比如你的源目录有
- download
- download2

比如你的硬链目录有
- 电影
- 电视剧
- 动漫

硬链和源文件应该是一一对应的，如果所以你要这样使用该命令：

1. 检查所有的硬链目录
```bash
hlink prune /path/to/download,/path/to/download2 /path/to/电影,/path/to/电视剧,/path/to/动漫
```

当然你也可以 **检测部分硬链目录** 像下面这样

2. 检测部分

```bash
hlink /path/to/download,/path/to/download2 /path/to/电影
```

因为 prune 的作用是 寻找 **源目录没有而硬链目录有的情况，所以我建议你源目录一定一定列全量**，否则可能存在下面的情况：

源目录1 -> 硬链目录1
源目录2 -> 硬链目录2

如果你这时候只告诉hlink 部分源目录，比如源目录1
```bash
hlink prune /path/to/源目录1 /path/to/硬链目录1,/path/to/硬链目录2
```

那这样造成的结果就会检测出来 **硬链目录2** 的文件，全部都找不到，全都会被修剪掉，因为它里面的文件全是从 **源目录2** 来的。

所以你自己无法确认对应关系，那么建议你
1. 使用正向检测时：**源目录一定一定要列全，硬链目录则可以随意**
2. 使用反向检测时：**硬链目录一定一定要列全，源目录则可以随意**

更多使用配置可以见`hlink prune --help`

注意点：
- 因为我们采用 **,(英文逗号)** 来进行多项输入，所以你的路径一定不要包含 **,(英文逗号)**。否则会导致未知错误，后果自负~
- 你自己无法确认对应关系，那么建议你 **源目录一定一定要列全，硬链目录则可以随意（至少一个）**
- `includeExtname` 和 `excludeExtname` 建议和硬链时保持一致

以上就是对 `hlink prune` 的所有介绍，有问题可以群里咨询

## v2.0prune改动

为保证源目录和硬链目录的文件追踪，v2.0prune取消了命令行录入目录，都是通过和主命令使用同一个配置文件来实现。详情见 [prune使用说明](../command/prune.md)



